<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ARC Code Challenge</title>
<script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js"></script>
<style>
:root {
    --bg-color: #1e3050;
    --header-bg: #2a4166;
    --panel-bg: #d0d8e8;
    --accent-bg: #ffffff;
    --grid-bg: #1e3050;
    --border-color: #ffffff;
    --text-color: #ffffff;
    --x-axis-color: #ff5959; /* Red for X axis */
    --y-axis-color: #59ff59; /* Green for Y axis */
    --label-color: #1e3050;
    --title-color: #ffff59;
    --button-color: #59ff59;
    --button-hover: #3fd33f;
    --button-active: #2eaf2e;
    --pixel-white: #ffffff;
    --pixel-black: #000000;
    --pixel-red: #ff5959;
    --pixel-blue: #5959ff;
    --pixel-green: #59ff59;
    --pixel-yellow: #ffff59;
    --pixel-magenta: #ff59ff;
    --pixel-cyan: #59ffff;
    --editor-bg: #1e1e1e;
    --editor-header: #2d2d2d;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: "Courier New", monospace;
    background-color: var(--bg-color);
    color: var(--text-color);
    line-height: 1.5;
    padding: 20px;
    height: 100vh;
    letter-spacing: 0.5px;
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    font-size: 20px;
    color: var(--title-color);
    text-transform: uppercase;
    background-color: var(--header-bg);
    padding: 10px;
    border: 1px solid var(--border-color);
    font-weight: normal;
}

.container {
    display: flex;
    height: calc(100vh - 100px);
    gap: 10px;
}

/* Editor Panel */
.editor-panel {
    display: flex;
    flex-direction: column;
    background: var(--editor-bg);
    overflow: hidden;
    flex: 1;
    min-width: 300px;
    border: 1px solid var(--border-color);
}

.editor-header {
    display: flex;
    background: var(--editor-header);
    border-bottom: 1px solid var(--border-color);
    padding: 8px 16px;
    justify-content: space-between;
    align-items: center;
}

.editor-title {
    color: var(--title-color);
    font-size: 14px;
    text-transform: uppercase;
}

/* Editor tabs */
.editor-tabs {
    display: flex;
    background: var(--editor-header);
    border-bottom: 1px solid var(--border-color);
}

.editor-tab {
    padding: 10px 20px;
    color: var(--text-color);
    cursor: pointer;
    border-right: 1px solid var(--border-color);
    transition: background-color 0.2s ease;
    font-size: 14px;
}

.editor-tab:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.editor-tab.active {
    background-color: var(--editor-bg);
    border-bottom: 2px solid var(--button-color);
}

.editor-container {
    position: relative;
    flex-grow: 1;
    display: flex;
}

.editor-instance {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    display: none;
}

.editor-instance.active {
    display: block;
}

/* Right Panel - Grid Viewer */
.grid-panel {
    display: flex;
    flex-direction: column;
    background: var(--editor-bg);
    overflow: hidden;
    flex: 1;
    min-width: 300px;
    border: 1px solid var(--border-color);
}

.grid-header {
    display: flex;
    background: var(--editor-header);
    border-bottom: 1px solid var(--border-color);
    padding: 8px 16px;
    justify-content: space-between;
    align-items: center;
}

.grid-title {
    color: var(--title-color);
    font-size: 14px;
    text-transform: uppercase;
}

.grid-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 0 0 0; /* Remove horizontal padding for full-width panels */
    flex-grow: 1;
    overflow-y: auto;
    justify-content: space-between; /* Push content to top and bottom */
}

/* Grid Container */
.grid-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
    margin-bottom: 0; /* Remove bottom margin to let panels be closer */
    padding: 0 20px;
    width: 100%;
    flex-shrink: 0; /* Prevent shrinking */
}

.grid-section {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.grid-title {
    font-size: 14px;
    margin-bottom: 10px;
    text-transform: uppercase;
    color: var(--title-color);
    background-color: var(--header-bg);
    padding: 5px 10px;
    width: 100%;
    text-align: center;
    border: 1px solid var(--border-color);
}

.grid-wrapper {
    position: relative;
    width: 340px;
    height: 340px;
    background-color: var(--grid-bg);
    border: 1px solid var(--border-color);
    padding: 30px 0 0 30px; /* Space for axes */
    box-sizing: border-box;
}

.grid-inner {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: transparent;
    border-left: 2px solid var(--y-axis-color);
    border-top: 2px solid var(--x-axis-color);
}

/* X and Y axes */
.x-axis {
    position: absolute;
    top: 0;
    left: 30px;
    right: 0;
    height: 2px;
    background-color: var(--x-axis-color);
    z-index: 1;
}

.y-axis {
    position: absolute;
    top: 30px;
    bottom: 0;
    left: 0;
    width: 2px;
    background-color: var(--y-axis-color);
    z-index: 1;
}

/* Tick marks */
.tick {
    position: absolute;
    z-index: 2;
}

.x-tick {
    width: 2px;
    height: 5px;
    top: 15px; /* Points upward */
    background-color: var(--x-axis-color);
}

.y-tick {
    width: 5px;
    height: 2px;
    left: 15px; /* Points to the left */
    background-color: var(--y-axis-color);
}

/* Axis labels */
.axis-labels {
    position: absolute;
    font-size: 12px;
    z-index: 2;
    font-weight: bold;
}

.x-labels {
    top: -20px; /* Now above the x-axis */
    left: 0;
    right: 0;
}

.y-labels {
    top: 0;
    bottom: 0;
    left: -20px; /* Now to the left of y-axis */
}

.x-label, .y-label {
    position: absolute;
    color: var(--text-color);
    width: 20px;
    text-align: center;
    background-color: transparent;
    border: none;
}

.x-label {
    transform: translateX(-50%);
}

.y-label {
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translateY(-50%);
}

/* Axis names */
.axis-name {
    position: absolute;
    font-weight: bold;
    z-index: 2;
}

.x-name {
    top: -20px;
    right: 10px;
    color: var(--x-axis-color);
}

.y-name {
    left: -20px;
    bottom: 10px;
    color: var(--y-axis-color);
}

/* Origin label */
.origin-label {
    position: absolute;
    top: -20px;
    left: -20px;
    width: 20px;
    height: 20px;
    color: var(--text-color);
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    z-index: 3;
}

/* Arrow styles */
.x-arrow-right {
    position: absolute;
    right: 2px;
    top: 0;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-left: 8px solid var(--x-axis-color);
    z-index: 2;
}

.y-arrow-down {
    position: absolute;
    bottom: 2px;
    left: 0;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 8px solid var(--y-axis-color);
    z-index: 2;
}

/* Origin marker */
.origin-marker {
    position: absolute;
    top: 0;
    left: 0;
    width: 6px;
    height: 6px;
    background-color: #5959ff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 3;
}

.grid {
    position: relative;
    display: inline-block;
    background-color: transparent;
    z-index: 4;
}

.grid-row {
    display: flex;
}

.grid-cell {
    /* Base properties for all cells */
    border: 0;
    position: relative;
    transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* Grid cell sizes for different grid dimensions */
.grid-cell-small {  /* For grids 3x3 to 5x5 */
    width: 55px;
    height: 55px;
    margin: 1px;
}

.grid-cell-medium { /* For grids 6x6 to 10x10 */
    width: 27px;
    height: 27px;
    margin: 1px;
}

.grid-cell-large {  /* For grids 11x11 to 20x20 */
    width: 13px;
    height: 13px;
    margin: 0.5px;
}

.grid-cell-xlarge { /* For grids 21x21 to 30x30 */
    width: 8px;
    height: 8px;
    margin: 0.5px;
}

.grid-cell:hover {
    transform: scale(1.05);
    z-index: 5;
    box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
}

.grid-cell:hover::after {
    content: attr(data-coords) ":" attr(data-value);
    position: absolute;
    top: -25px;
    left: 0;
    background-color: var(--header-bg);
    color: var(--text-color);
    padding: 2px 5px;
    border: 1px solid var(--border-color);
    font-size: 10px;
    white-space: nowrap;
    z-index: 10;
}

/* Pop animation */
.pop-in {
    animation: popIn 0.8s cubic-bezier(0.25, 1.5, 0.5, 1.2);
}

@keyframes popIn {
    0% { 
        transform: scale(0.05); 
    }
    60% { 
        transform: scale(1.15);
    }
    80% {
        transform: scale(0.95);
    }
    100% { 
        transform: scale(1); 
    }
}

/* Run button */
.run-button {
    background-color: var(--button-color);
    color: var(--bg-color);
    border: 1px solid var(--border-color);
    padding: 6px 20px;
    font-family: "Courier New", monospace;
    font-size: 14px;
    font-weight: bold;
    text-transform: uppercase;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s ease;
    letter-spacing: 2px;
}

.run-button:hover {
    background-color: var(--button-hover);
}

.run-button:active {
    background-color: var(--button-active);
}

.run-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transform: translateX(-100%);
}

.run-button.running::before {
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* Loading overlay */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(30, 48, 80, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.loading-overlay.active {
    opacity: 1;
    pointer-events: all;
}

.loading-spinner {
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top: 3px solid var(--button-color);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Status indicator */
.status-indicator {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    color: var(--button-color);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 10; /* Ensure it appears above other elements */
}

.status-indicator.active {
    opacity: 1;
}

/* Color key bar */
.color-key-bar {
    display: flex;
    overflow-x: auto;
    background-color: var(--editor-header);
    border-top: 1px solid var(--border-color);
    color: var(--text-color);
    font-size: 12px;
    padding: 4px 8px;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
}

.color-key-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.color-box {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 1px solid var(--border-color);
}

/* Task Section Styles */
.task-section {
    width: 100%;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
    background-color: var(--editor-bg);
    border-radius: 3px;
    overflow: hidden;
}

.task-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: var(--header-bg);
    color: var(--title-color);
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
}

.task-header:hover {
    background-color: rgba(42, 65, 102, 0.8);
}

.task-title {
    font-size: 16px;
    font-weight: bold;
    text-transform: uppercase;
}

.task-stats {
    font-size: 12px;
    color: var(--text-color);
    display: flex;
    gap: 12px;
    align-items: center;
}

.task-match, .task-transform-match {
    font-weight: bold;
}

.task-content {
    padding: 0;
    max-height: 1200px;
    overflow: hidden;
    transition: max-height 0.5s ease-out;
}

.task-content.collapsed {
    max-height: 0;
}

/* Grid Comparison Row */
.grid-comparison {
    display: flex;
    justify-content: space-between;
    padding: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.grid-comparison-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.grid-comparison-title {
    font-size: 14px;
    margin-bottom: 10px;
    text-transform: uppercase;
    color: var(--title-color);
}

/* Run Transform Button */
.run-transform-button {
    background-color: var(--button-color);
    color: var(--bg-color);
    border: none;
    padding: 5px 15px;
    margin: 10px 0;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    font-family: inherit;
    text-transform: uppercase;
    transition: background-color 0.2s;
}

.run-transform-button:hover {
    background-color: var(--button-hover);
}

.run-transform-button:disabled {
    background-color: #555;
    cursor: not-allowed;
}

/* Task Warning */
.task-warning {
    background-color: rgba(255, 200, 0, 0.1);
    color: #ffcc00;
    padding: 8px 12px;
    font-size: 12px;
    margin: 10px 0;
    border-left: 3px solid #ffcc00;
}

.tasks-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    margin-bottom: 20px;
    padding: 0 20px;
}

/* Bottom panels container */
.bottom-panels {
    display: flex;
    width: 100%;
    gap: 10px;
    margin-top: auto; /* Push to bottom */
    padding: 20px;  /* Add padding on all sides */
    flex-shrink: 0; /* Prevent shrinking */
}

/* Results panel */
.results-panel {
    flex: 1;
    background-color: var(--panel-bg);
    color: var(--label-color);
    border: 1px solid var(--border-color);
    max-width: none;
    margin-bottom: 0;
}

.results-header {
    background-color: var(--header-bg);
    color: var(--title-color);
    padding: 5px 10px;
    font-size: 14px;
    text-transform: uppercase;
    border-bottom: 1px solid var(--border-color);
}

.results-content {
    padding: 10px;
    min-height: 180px; /* Match the debug output height */
}

.results-row {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px solid rgba(30, 48, 80, 0.2);
}

.results-label {
    font-weight: bold;
    font-size: 14px;
}

.results-value {
    font-family: "Courier New", monospace;
    font-size: 14px;
}

/* Special styling for task status */
#task-status {
    font-weight: bold;
    transition: color 0.3s;
}

.results-footer {
    margin-top: 20px;
    padding-top: 10px;
    border-top: 1px dashed rgba(30, 48, 80, 0.3);
    justify-content: center;
}

.results-note {
    font-size: 14px;
    font-style: italic;
    text-align: center;
}

/* Debug panel */
.debug-panel {
    flex: 1;
    background-color: var(--panel-bg);
    color: var(--label-color);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
}

.debug-header {
    background-color: var(--header-bg);
    color: var(--title-color);
    padding: 5px 10px;
    font-size: 14px;
    text-transform: uppercase;
    border-bottom: 1px solid var(--border-color);
}

.debug-content {
    padding: 10px;
    height: calc(100% - 28px); /* Account for header height */
}

/* For debugging */
.debug-output {
    width: 100%;
    height: 180px; /* Increased height */
    overflow-y: auto;
    background-color: var(--editor-bg);
    color: var(--text-color);
    border: 1px solid rgba(30, 48, 80, 0.3);
    font-family: monospace;
    font-size: 13px; /* Slightly increased font size */
    padding: 8px;
    white-space: pre-wrap;
    border-radius: 2px;
}

/* Version label */
.version-label {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 10px;
    color: var(--text-color);
    opacity: 0.7;
}

/* Task Selector */
.task-select-header {
    width: 100%;
    padding: 6px 10px;
    background-color: var(--editor-header);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    font-family: "Courier New", monospace;
    font-size: 14px;
    text-transform: uppercase;
}

/* Resizer */
.resizer {
    width: 8px;
    height: 100%;
    background: #333;
    cursor: col-resize;
    transition: background 0.2s;
    z-index: 10;
}

.resizer:hover {
    background: #555;
}

.resizer.active {
    background: var(--button-color);
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        flex-direction: column;
        height: auto;
    }

    .editor-panel, .grid-panel {
        height: 500px;
        min-width: 100%;
    }

    .resizer {
        width: 100%;
        height: 8px;
        cursor: row-resize;
    }
}
</style>
</head>
<body>
    <h1>ARC CODE CHALLENGE</h1>
    <div class="container">
        <!-- Editor Panel -->
        <div class="editor-panel">
            <div class="editor-header">
                <button class="run-button" id="run-button">RUN</button>
            </div>
            <div class="editor-tabs">
                <div class="editor-tab active" data-tab="solution">solution.py</div>
                <div class="editor-tab" data-tab="library">library.py</div>
            </div>
            <div class="editor-container">
                <!-- Solution Editor -->
                <div id="solution-editor" class="editor-instance active">from library import Grid, V, Color, Rectangle, Line

def create_grid_1() -> Grid:
    """Predict the first input grid"""
    # Create a 3x3 grid with a diagonal green line
    size = V(x=3, y=3)

    grid = Grid(
        size=size,
        color=Color.BLACK,
        layers=[]
    )

    # Add a diagonal line
    grid.layers.append(
        Line(
            start=V(x=0, y=0),
            end=V(x=2, y=2),
            color=Color.GREEN
        )
    )

    return grid

def create_grid_2() -> Grid:
    """Predict the second input grid"""
    # Create a 3x3 grid with a diagonal green line
    size = V(x=3, y=3)

    grid = Grid(
        size=size,
        color=Color.BLACK,
        layers=[]
    )

    # Add a diagonal line
    grid.layers.append(
        Line(
            start=V(x=0, y=0),
            end=V(x=2, y=2),
            color=Color.GREEN
        )
    )

    return grid

def create_grid_3() -> Grid:
    """Predict the third input grid"""
    # Create a 3x3 grid with a diagonal green line
    size = V(x=3, y=3)

    grid = Grid(
        size=size,
        color=Color.BLACK,
        layers=[]
    )

    # Add a diagonal line
    grid.layers.append(
        Line(
            start=V(x=0, y=0),
            end=V(x=2, y=2),
            color=Color.GREEN
        )
    )

    return grid

def to_output(grid: Grid) -> Grid:
    """Transform an input grid to match the expected output pattern

    This function takes an input grid and applies a transformation to 
    produce the corresponding output grid according to the task pattern.

    Args:
        grid: The input Grid object

    Returns:
        A new Grid object representing the predicted output
    """
    # Default implementation: just return the same grid
    # Modify this function to implement the transformation you discover
    return grid

</div>
                <!-- Library Editor -->
                <div id="library-editor" class="editor-instance">from enum import Enum

import numpy as np
from pydantic import BaseModel


class V(BaseModel):
    x: int
    y: int


class Color(int, Enum):
    BLACK = 0
    BLUE = 1
    RED = 2
    GREEN = 3
    YELLOW = 4
    GRAY = 5
    PINK = 6
    ORANGE = 7
    TEAL = 8
    MAGENTA = 9


class BaseDrawer(BaseModel):
    def apply(self, canvas: np.ndarray) -> np.ndarray:
        raise NotImplementedError()


class Grid(BaseModel):
    size: V
    color: Color
    layers: list[BaseDrawer]

    def render(self) -> list[list[int]]:
        # canvas starts as all `-1` in the background
        canvas = np.ones((self.size.y, self.size.x), dtype=np.int32) * -1
        for layer in self.layers:
            canvas = layer.apply(canvas)
        # replace `-1` with the background color
        mask = canvas == -1
        canvas = self.color * mask + canvas * ~mask
        return canvas.tolist()


class Rectangle(BaseDrawer):
    """Draw a rectangle on the canvas."""
    top_left: V
    bottom_right: V
    color: Color
    fill: bool = False

    def apply(self, canvas: np.ndarray) -> np.ndarray:
        result = canvas.copy()

        # Extract coordinates
        x1, y1 = self.top_left.x, self.top_left.y
        x2, y2 = self.bottom_right.x, self.bottom_right.y

        # Ensure coordinates are in bounds
        height, width = canvas.shape
        x1 = max(0, min(x1, width - 1))
        y1 = max(0, min(y1, height - 1))
        x2 = max(0, min(x2, width - 1))
        y2 = max(0, min(y2, height - 1))

        if self.fill:
            # Fill the rectangle
            result[y1:y2+1, x1:x2+1] = self.color
        else:
            # Draw only the border
            # Top and bottom edges
            result[y1, x1:x2+1] = self.color
            result[y2, x1:x2+1] = self.color
            # Left and right edges
            result[y1:y2+1, x1] = self.color
            result[y1:y2+1, x2] = self.color

        return result


class Line(BaseDrawer):
    """Draw a line on the canvas using Bresenham's algorithm."""
    start: V
    end: V
    color: Color

    def apply(self, canvas: np.ndarray) -> np.ndarray:
        result = canvas.copy()

        # Extract coordinates
        x1, y1 = self.start.x, self.start.y
        x2, y2 = self.end.x, self.end.y

        # Bresenham's Line Algorithm
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx - dy

        while True:
            # Check if point is within canvas bounds
            if 0 <= y1 < result.shape[0] and 0 <= x1 < result.shape[1]:
                result[y1, x1] = self.color

            if x1 == x2 and y1 == y2:
                break

            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x1 += sx
            if e2 < dx:
                err += dx
                y1 += sy

        return result
</div>
            </div>
            <!-- Color Key Bar -->
            <div class="color-key-bar">
                <div class="color-key-item"><span class="color-box" style="background-color: #000000;"></span>0:BLACK</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #0000FF;"></span>1:BLUE</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #FF0000;"></span>2:RED</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #00FF00;"></span>3:GREEN</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #FFFF00;"></span>4:YELLOW</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #808080;"></span>5:GRAY</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #FFC0CB;"></span>6:PINK</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #FFA500;"></span>7:ORANGE</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #008080;"></span>8:TEAL</div>
                <div class="color-key-item"><span class="color-box" style="background-color: #FF00FF;"></span>9:MAGENTA</div>
            </div>
        </div>

        <!-- Resizer -->
        <div class="resizer" id="panel-resizer"></div>

        <!-- Grid Viewer Panel -->
        <div class="grid-panel">
            <div class="grid-header">
                <select id="task-select" class="task-select-header">
                    <!-- Will be populated dynamically -->
                </select>
            </div>
            <div class="grid-content">

                <!-- Tasks Container -->
                <div class="tasks-container" id="tasks-container">
                    <!-- Task sections will be added here dynamically -->
                </div>

                <!-- Loading overlay (now global) -->
                <div class="loading-overlay" id="loading-overlay">
                    <div class="loading-spinner"></div>
                </div>

                <!-- Status indicator -->
                <div class="status-indicator" id="status-indicator">RUNNING PYTHON CODE...</div>

                <!-- Bottom panels container -->
                <div class="bottom-panels">
                    <!-- Solution Stats -->
                    <div class="results-panel">
                        <div class="results-header">SOLUTION STATS</div>
                        <div class="results-content">
                            <div class="results-row">
                                <div class="results-label">Code Length</div>
                                <div class="results-value" id="code-length">0 tokens</div>
                            </div>
                            <div class="results-row">
                                <div class="results-label">Inputs Matched</div>
                                <div class="results-value" id="inputs-matched">0/0 (0%)</div>
                            </div>
                            <div class="results-row">
                                <div class="results-label">Outputs Matched</div>
                                <div class="results-value" id="outputs-matched">0/0 (0%)</div>
                            </div>
                            <div class="results-row">
                                <div class="results-label">Task Status</div>
                                <div class="results-value" id="task-status">Not started</div>
                            </div>
                            <div class="results-row results-footer">
                                <div class="results-note">ðŸ’¡ Match all inputs and outputs to solve the task.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Debug panel -->
                    <div class="debug-panel">
                        <div class="debug-header">CONSOLE OUTPUT</div>
                        <div class="debug-content">
                            <div class="debug-output" id="debug-output"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="version-label">ARC Grid Challenge v1.0</div>

<script>
// Updated color mapping
const COLOR_MAP = {
    0: '#000000',    // BLACK
    1: '#0000FF',    // BLUE
    2: '#FF0000',    // RED
    3: '#00FF00',    // GREEN
    4: '#FFFF00',    // YELLOW
    5: '#808080',    // GRAY
    6: '#FFC0CB',    // PINK
    7: '#FFA500',    // ORANGE
    8: '#008080',    // TEAL
    9: '#FF00FF'     // MAGENTA
};

// Global variables
let solutionEditor;
let libraryEditor;
let currentEditor;
let pyodide = null;
let currentTask = null;
let taskList = [];

// Solution tracking variables
let solutionStats = {
    matchedInputs: 0,
    totalInputs: 0,
    matchedOutputs: 0,
    totalOutputs: 0,
    taskStatus: 'Not started'
};

// Initialize the editors
function initializeEditor() {
    // Initialize solution editor
    solutionEditor = ace.edit("solution-editor");
    solutionEditor.setTheme("ace/theme/monokai");
    solutionEditor.session.setMode("ace/mode/python");
    solutionEditor.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        highlightActiveLine: true,
        enableLiveAutocompletion: true
    });

    // Initialize library editor
    libraryEditor = ace.edit("library-editor");
    libraryEditor.setTheme("ace/theme/monokai");
    libraryEditor.session.setMode("ace/mode/python");
    libraryEditor.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        highlightActiveLine: true,
        enableLiveAutocompletion: true
    });

    // Set current editor to solution by default
    currentEditor = solutionEditor;

    // Add keyboard shortcut for running code to both editors
    const runCommand = {
        name: 'runCode',
        bindKey: {win: 'Shift-Enter', mac: 'Shift-Enter'},
        exec: function() {
            runPythonCode();
        }
    };

    solutionEditor.commands.addCommand(runCommand);
    libraryEditor.commands.addCommand(runCommand);

    // Set up tab switching
    setupTabSwitching();

    // Show shortcut info in the debug output
    document.getElementById('debug-output').textContent = "Press Shift+Enter to run your code";
}

// Setup tab switching functionality
function setupTabSwitching() {
    const tabs = document.querySelectorAll('.editor-tab');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Get the tab name
            const tabName = tab.getAttribute('data-tab');

            // Deactivate all tabs and editors
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.editor-instance').forEach(editor => {
                editor.classList.remove('active');
            });

            // Activate the clicked tab and corresponding editor
            tab.classList.add('active');
            document.getElementById(`${tabName}-editor`).classList.add('active');

            // Set the current editor
            if (tabName === 'solution') {
                currentEditor = solutionEditor;
            } else if (tabName === 'library') {
                currentEditor = libraryEditor;
            }

            // Resize the editor for proper rendering
            if (currentEditor) {
                currentEditor.resize();
            }
        });
    });
}

// Function to get color from value
function getColorFromValue(value) {
    return COLOR_MAP[value] || '#cccccc'; // Default gray for unknown values
}

// Helper function to get cell size in pixels based on grid dimensions
function getCellPixelSize(gridData) {
    const rows = gridData.length;
    const cols = gridData[0].length;
    const maxDim = Math.max(rows, cols);

    // Return cell size and margin based on grid dimensions
    if (maxDim <= 5) {
        return { size: 55, margin: 1 };
    } else if (maxDim <= 10) {
        return { size: 27, margin: 1 };
    } else if (maxDim <= 20) {
        return { size: 13, margin: 0.5 };
    } else {
        return { size: 8, margin: 0.5 };
    }
}

// Function to create axis labels and ticks
function createAxisLabels(gridData, xLabelsId, yLabelsId) {
    const xLabels = document.getElementById(xLabelsId);
    const yLabels = document.getElementById(yLabelsId);

    // Safety check if elements exist
    if (!xLabels || !yLabels) {
        console.error(`Axis label elements not found: ${xLabelsId}, ${yLabelsId}`);
        return;
    }

    xLabels.innerHTML = '';
    yLabels.innerHTML = '';

    // Bail early if gridData is invalid
    if (!gridData || !Array.isArray(gridData) || gridData.length === 0 || !Array.isArray(gridData[0])) {
        console.error('Invalid grid data provided to createAxisLabels');
        return;
    }

    // Get the cell size in pixels based on grid dimensions
    const { size, margin } = getCellPixelSize(gridData);
    const pixelStep = size + (2 * margin); // Total space each cell takes

    // Determine how many labels to show based on grid size
    // For larger grids, we'll show fewer labels to avoid clutter
    const maxDim = Math.max(gridData.length, gridData[0].length);
    let labelInterval = 1; // Show all labels for small grids

    if (maxDim > 10 && maxDim <= 20) {
        labelInterval = 2; // Show every other label for medium grids
    } else if (maxDim > 20) {
        labelInterval = 5; // Show every fifth label for large grids
    }

    try {
        // X-axis labels (starting from 1)
        for (let x = 1; x < gridData[0].length; x++) {
            const pixelPos = x * pixelStep;

            // Create tick mark for all positions
            const tick = document.createElement('div');
            tick.className = 'tick x-tick';
            tick.style.left = `${pixelPos}px`;
            xLabels.appendChild(tick);

            // Only create labels at intervals to avoid clutter
            if (x % labelInterval === 0 || x === gridData[0].length - 1) {
                const label = document.createElement('div');
                label.className = 'x-label';
                label.textContent = x;

                // Position the label along the x-axis
                label.style.left = `${pixelPos}px`;

                // Adjust font size for larger grids
                if (maxDim > 20) {
                    label.style.fontSize = '8px';
                } else if (maxDim > 10) {
                    label.style.fontSize = '10px';
                }

                xLabels.appendChild(label);
            }
        }

        // Y-axis labels (starting from 1)
        for (let y = 1; y < gridData.length; y++) {
            const pixelPos = y * pixelStep;

            // Create tick mark for all positions
            const tick = document.createElement('div');
            tick.className = 'tick y-tick';
            tick.style.top = `${pixelPos}px`;
            yLabels.appendChild(tick);

            // Only create labels at intervals to avoid clutter
            if (y % labelInterval === 0 || y === gridData.length - 1) {
                const label = document.createElement('div');
                label.className = 'y-label';
                label.textContent = y;

                // Position the label along the y-axis
                label.style.top = `${pixelPos}px`;

                // Adjust font size for larger grids
                if (maxDim > 20) {
                    label.style.fontSize = '8px';
                } else if (maxDim > 10) {
                    label.style.fontSize = '10px';
                }

                yLabels.appendChild(label);
            }
        }
    } catch (error) {
        console.error('Error creating axis labels:', error);
    }
}

// Helper function to determine cell size class based on grid dimensions
function getCellSizeClass(gridData) {
    const rows = gridData.length;
    const cols = gridData[0].length;
    const maxDim = Math.max(rows, cols);

    if (maxDim <= 5) {
        return 'grid-cell-small';
    } else if (maxDim <= 10) {
        return 'grid-cell-medium';
    } else if (maxDim <= 20) {
        return 'grid-cell-large';
    } else {
        return 'grid-cell-xlarge';
    }
}

// Function to render a grid
function renderGrid(gridData, containerId) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Grid container not found: ${containerId}`);
        return;
    }

    // Bail early if gridData is invalid
    if (!gridData || !Array.isArray(gridData) || gridData.length === 0 || !Array.isArray(gridData[0])) {
        console.error('Invalid grid data provided to renderGrid');
        return;
    }

    container.innerHTML = ''; // Clear previous content

    try {
        // Get the appropriate cell size class
        const cellSizeClass = getCellSizeClass(gridData);

        gridData.forEach((row, y) => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'grid-row';

            row.forEach((cell, x) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = `grid-cell ${cellSizeClass}`;
                cellDiv.style.backgroundColor = getColorFromValue(cell);

                // Use standard coordinates starting from (0,0)
                cellDiv.dataset.coords = `(${x},${y})`;
                cellDiv.dataset.value = cell;

                rowDiv.appendChild(cellDiv);
            });

            container.appendChild(rowDiv);
        });

        // Update axis labels for the new grid size
        const targetWrapper = container.closest('.grid-wrapper');
        if (targetWrapper) {
            adjustGridWrapperForSize(targetWrapper, gridData);
        }
    } catch (error) {
        console.error('Error rendering grid:', error);
    }
}

// Function to adjust grid wrapper and axes for different grid sizes
function adjustGridWrapperForSize(wrapper, gridData) {
    if (!wrapper) {
        console.error('Grid wrapper not provided to adjustGridWrapperForSize');
        return;
    }

    // Bail early if gridData is invalid
    if (!gridData || !Array.isArray(gridData) || gridData.length === 0 || !Array.isArray(gridData[0])) {
        console.error('Invalid grid data provided to adjustGridWrapperForSize');
        return;
    }

    try {
        const maxDim = Math.max(gridData.length, gridData[0].length);

        // Get the cell size based on grid dimensions
        const { size } = getCellPixelSize(gridData);

        // For very small grids (3x3 to 5x5), we can use larger ticks
        if (maxDim <= 5) {
            wrapper.querySelectorAll('.x-tick, .y-tick').forEach(el => {
                if (el.classList.contains('x-tick')) {
                    el.style.height = '6px';
                } else {
                    el.style.width = '6px';
                }
            });
        }
        // For very large grids, reduce tick size
        else if (maxDim > 20) {
            wrapper.querySelectorAll('.x-tick, .y-tick').forEach(el => {
                if (el.classList.contains('x-tick')) {
                    el.style.height = '3px';
                } else {
                    el.style.width = '3px';
                }
            });
        }
    } catch (error) {
        console.error('Error adjusting grid wrapper:', error);
    }
}

// Function to render grid with slower pop animation
function renderGridWithPopAnimation(gridData, containerId) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Grid container not found: ${containerId}`);
        return;
    }

    // Bail early if gridData is invalid
    if (!gridData || !Array.isArray(gridData) || gridData.length === 0 || !Array.isArray(gridData[0])) {
        console.error('Invalid grid data provided to renderGridWithPopAnimation');
        return;
    }

    container.innerHTML = ''; // Clear previous content

    try {
        // Get the appropriate cell size class
        const cellSizeClass = getCellSizeClass(gridData);

        // First create all cells with their final colors but tiny size
        gridData.forEach((row, y) => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'grid-row';

            row.forEach((cell, x) => {
                const cellDiv = document.createElement('div');
                cellDiv.className = `grid-cell ${cellSizeClass}`;
                cellDiv.style.backgroundColor = getColorFromValue(cell);
                cellDiv.style.transform = 'scale(0.05)'; // Start very small

                // Use standard coordinates starting from (0,0)
                cellDiv.dataset.coords = `(${x},${y})`;
                cellDiv.dataset.value = cell;

                rowDiv.appendChild(cellDiv);
            });

            container.appendChild(rowDiv);
        });

        // Update axis labels for the new grid size
        const targetWrapper = container.closest('.grid-wrapper');
        if (targetWrapper) {
            adjustGridWrapperForSize(targetWrapper, gridData);
        }

        // Add a slight delay then make all cells pop at once
        setTimeout(() => {
            const cells = container.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                cell.classList.add('pop-in');
                cell.style.transform = ''; // Remove inline transform to let animation work
            });
        }, 200); // Slightly longer delay before animation starts
    } catch (error) {
        console.error('Error rendering grid with animation:', error);
    }
}


// Check if two grids have the same dimensions
function isSameDimensions(grid1, grid2) {
    if (!grid1 || !grid2 || grid1.length === 0 || grid2.length === 0) {
        return false;
    }

    return grid1.length === grid2.length && grid1[0].length === grid2[0].length;
}

// Calculate similarity between grids - only counts exact matches
function calculateSimilarity(userGrid, targetGrid) {
    if (!userGrid || !targetGrid || userGrid.length === 0 || targetGrid.length === 0) {
        return 0;
    }

    // We'll compare within the intersection of the two grids
    const rows = Math.min(userGrid.length, targetGrid.length);
    const cols = Math.min(userGrid[0].length, targetGrid[0].length);

    // Count matches in the intersection area
    let matches = 0;
    let total = rows * cols;

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            if (userGrid[y][x] === targetGrid[y][x]) {
                matches++;
            }
        }
    }

    return (matches / total) * 100;
}

// This functionality is now handled directly in the task comparison sections

// Hard-coded list of task files
// In a real server environment, you would fetch this dynamically
function getTaskFiles() {
    // All ARC task files
    const taskFiles = [
        // Training dataset (easier tasks)
        { id: "007bbfb7", path: "/data/training/007bbfb7.json" },
        { id: "00d62c1b", path: "/data/training/00d62c1b.json" },
        { id: "017c7c7b", path: "/data/training/017c7c7b.json" },
        { id: "025d127b", path: "/data/training/025d127b.json" },
        { id: "045e512c", path: "/data/training/045e512c.json" },
        { id: "0520fde7", path: "/data/training/0520fde7.json" },
        { id: "05269061", path: "/data/training/05269061.json" },
        { id: "05f2a901", path: "/data/training/05f2a901.json" },
        { id: "06df4c85", path: "/data/training/06df4c85.json" },
        { id: "08ed6ac7", path: "/data/training/08ed6ac7.json" },
        { id: "09629e4f", path: "/data/training/09629e4f.json" },
        { id: "0962bcdd", path: "/data/training/0962bcdd.json" },
        
        // Evaluation dataset (harder tasks)
        { id: "00576224", path: "/data/evaluation/00576224.json" },
        { id: "009d5c81", path: "/data/evaluation/009d5c81.json" },
        { id: "00dbd492", path: "/data/evaluation/00dbd492.json" },
        { id: "03560426", path: "/data/evaluation/03560426.json" },
        { id: "05a7bcf2", path: "/data/evaluation/05a7bcf2.json" },
        { id: "0607ce86", path: "/data/evaluation/0607ce86.json" },
        { id: "0692e18c", path: "/data/evaluation/0692e18c.json" },
        { id: "070dd51e", path: "/data/evaluation/070dd51e.json" },
        { id: "08573cc6", path: "/data/evaluation/08573cc6.json" },
        { id: "0934a4d8", path: "/data/evaluation/0934a4d8.json" },
        { id: "09c534e7", path: "/data/evaluation/09c534e7.json" },
        { id: "0a1d4ef5", path: "/data/evaluation/0a1d4ef5.json" }
    ];

    return taskFiles;
}

// Load the task list
async function loadTaskList() {
    try {
        // Get the task files
        taskList = getTaskFiles();
    } catch (error) {
        console.error('Error loading task list:', error);
        // Fallback to a hardcoded first task for demo
        taskList = [
            { id: '007bbfb7', path: '/data/training/007bbfb7.json' }
        ];
    }

    // Create task groups in the dropdown
    const select = document.getElementById('task-select');
    select.innerHTML = ''; // Clear any existing options

    // Add an optgroup for each dataset source (based on path)
    const typeGroups = {
        'Training': document.createElement('optgroup'),
        'Evaluation': document.createElement('optgroup')
    };
    
    typeGroups['Training'].label = 'Training Tasks';
    typeGroups['Evaluation'].label = 'Evaluation Tasks';
    
    select.appendChild(typeGroups['Training']);
    select.appendChild(typeGroups['Evaluation']);

    taskList.forEach(task => {
        // Determine if this is a training or evaluation task based on path
        const type = task.path.includes('/training/') ? 'Training' : 'Evaluation';
        
        // Add the option to the appropriate group
        const option = document.createElement('option');
        option.value = task.id;
        option.textContent = task.id;
        typeGroups[type].appendChild(option);
    });

    // Load the first task
    if (taskList.length > 0) {
        select.value = taskList[0].id;
        loadTask(taskList[0].id);
    }
}

// Load a specific task
async function loadTask(taskId) {
    const debugOutput = document.getElementById('debug-output');
    const tasksContainer = document.getElementById('tasks-container');
    debugOutput.textContent = `Loading task ${taskId}...`;

    try {
        const task = taskList.find(t => t.id === taskId);
        if (!task) {
            throw new Error(`Task ${taskId} not found`);
        }

        const response = await fetch(task.path);
        if (!response.ok) {
            throw new Error(`Failed to load task ${taskId}`);
        }

        const taskData = await response.json();
        currentTask = taskData;

        // Clear previous task sections
        tasksContainer.innerHTML = '';

        // Reset solution stats for the new task
        solutionStats.matchedInputs = 0;
        solutionStats.matchedOutputs = 0;
        solutionStats.taskStatus = 'Not started';
        
        // Count total inputs and outputs for stats tracking
        let totalTasks = 0;
        
        // Both training and evaluation tasks can have train and test samples
        if (taskData.train) {
            totalTasks += taskData.train.length;
        }
        if (taskData.test) {
            totalTasks += taskData.test.length;
        }
        
        solutionStats.totalInputs = totalTasks;
        solutionStats.totalOutputs = totalTasks;
        
        // Update the solution stats display
        updateSolutionStatsDisplay();

        // Load training examples first (if any)
        if (taskData.train && taskData.train.length > 0) {
            // Create a task section for each training example
            taskData.train.forEach((example, idx) => {
                const taskNumber = idx + 1;
                const { section, renderGrids } = createTaskSection(
                    taskNumber, 
                    example.input, 
                    example.output, 
                    true, // isTraining
                    "Training"
                );

                // Add the section to the DOM
                tasksContainer.appendChild(section);

                // Render the grids after the section is in the DOM
                renderGrids();

                // Add click handlers for the prediction and transform buttons
                setupButtonHandlers(taskNumber, example.input);
            });
        }
        
        // Load test examples (if any)
        if (taskData.test && taskData.test.length > 0) {
            // Create a task section for each test example
            taskData.test.forEach((example, idx) => {
                // Continue task numbering from where training examples left off
                const taskNumber = (taskData.train ? taskData.train.length : 0) + idx + 1;
                const { section, renderGrids } = createTaskSection(
                    taskNumber, 
                    example.input, 
                    example.output, // Pass the output but it will be handled differently
                    false, // Not a training example
                    "Test"
                );

                // Add the section to the DOM
                tasksContainer.appendChild(section);

                // Render the grids after the section is in the DOM
                renderGrids();

                // Add click handlers for the prediction and transform buttons
                setupButtonHandlers(taskNumber, example.input, example.output);
            });
        }

        // Make sure the tasks container is visible
        tasksContainer.style.display = 'flex';

        // Update code metrics - get current solution code
        const currentCode = solutionEditor ? solutionEditor.getValue() : "";
        document.getElementById('code-length').textContent = "";

        // Update the debug output with task type info
        debugOutput.textContent = `Task ${taskId} loaded with ${taskData.train ? taskData.train.length : 0} training and ${taskData.test ? taskData.test.length : 0} test examples.`;
    } catch (error) {
        console.error('Error loading task:', error);
        debugOutput.textContent = `Error loading task: ${error.message}`;

        // Hide tasks container
        tasksContainer.style.display = 'none';
    }
}

// Set up button handlers for prediction and transform
function setupButtonHandlers(taskNumber, inputGrid, actualOutput = null) {
    // The prediction button runs create_grid_N
    const predictionButton = document.getElementById(`run-prediction-${taskNumber}`);
    if (predictionButton) {
        predictionButton.addEventListener('click', async () => {
            try {
                // First get the current solution code and library code
                const solutionCode = solutionEditor.getValue();
                const libraryCode = libraryEditor.getValue();

                // Load the modules
                loadPythonModules(libraryCode, solutionCode);

                // Try to run the create_grid function for this task
                const funcName = `create_grid_${taskNumber}`;

                // Run the prediction function and get the grid data
                const predictedGrid = pyodide.runPython(`${funcName}().render()`).toJs();

                // Display the predicted grid
                const safeIndex = taskNumber.toString().replace(/[^a-zA-Z0-9-]/g, '-');
                createAxisLabels(predictedGrid, `predicted-input-x-${safeIndex}`, `predicted-input-y-${safeIndex}`);
                renderGridWithPopAnimation(predictedGrid, `predicted-input-grid-${safeIndex}`);

                // Store the input grid in a global variable for the transform button
                window[`inputGrid${taskNumber}`] = predictedGrid;

                // Enable the transform button once prediction has been run
                const transformButton = document.getElementById(`run-transform-${taskNumber}`);
                if (transformButton) {
                    transformButton.disabled = false;
                }

                // Calculate similarity between predicted and actual input
                const matchPercent = calculateSimilarity(predictedGrid, inputGrid);

                // Update match percentage in the task header
                const taskHeader = document.querySelector(`#task-section-${taskNumber} .task-header .task-stats`);
                const existingMatchSpan = taskHeader.querySelector('.task-match');
                
                if (existingMatchSpan) {
                    existingMatchSpan.textContent = `Match: ${matchPercent.toFixed(1)}%`;
                    // Color the match based on percentage
                    if (matchPercent > 95) {
                        existingMatchSpan.style.color = 'var(--button-color)'; // Green
                    } else if (matchPercent > 50) {
                        existingMatchSpan.style.color = '#ffaa00'; // Orange
                    } else {
                        existingMatchSpan.style.color = '#ff5959'; // Red
                    }
                } else {
                    // Create new match span if it doesn't exist
                    const matchSpan = document.createElement('span');
                    matchSpan.className = 'task-match';
                    matchSpan.textContent = `Match: ${matchPercent.toFixed(1)}%`;
                    
                    // Color the match based on percentage
                    if (matchPercent > 95) {
                        matchSpan.style.color = 'var(--button-color)'; // Green
                    } else if (matchPercent > 50) {
                        matchSpan.style.color = '#ffaa00'; // Orange
                    } else {
                        matchSpan.style.color = '#ff5959'; // Red
                    }
                    
                    taskHeader.appendChild(matchSpan);
                }
                
                // Reset the button text
                predictionButton.textContent = 'Run Prediction';
                
                // Update solution stats for inputs
                if (matchPercent > 95) {
                    // Mark this input as matched if it wasn't already
                    const inputIdx = taskNumber - 1;
                    if (inputIdx >= 0 && inputIdx < solutionStats.totalInputs) {
                        if (!window[`inputMatched${taskNumber}`]) {
                            window[`inputMatched${taskNumber}`] = true;
                            solutionStats.matchedInputs++;
                            updateSolutionStats();
                        }
                    }
                }

            } catch (error) {
                console.error(`Error running prediction for task ${taskNumber}:`, error);
                document.getElementById('debug-output').textContent = 
                    `Error: ${error.message}. Make sure you've defined function create_grid_${taskNumber}() in your code.`;
            }
        });
    }

    // The transform button runs to_output on the predicted input
    const transformButton = document.getElementById(`run-transform-${taskNumber}`);
    if (transformButton) {
        transformButton.addEventListener('click', async () => {
            try {
                // Make sure we have a predicted input grid
                const storedInputGrid = window[`inputGrid${taskNumber}`];
                if (!storedInputGrid) {
                    throw new Error('Run the prediction first to generate input grid.');
                }

                // First get and execute the current solution code again
                // (in case it was modified since the prediction)
                const solutionCode = solutionEditor.getValue();
                const libraryCode = libraryEditor.getValue();

                // Load the modules
                loadPythonModules(libraryCode, solutionCode);

                // Check that the to_output function exists
                const hasFunction = pyodide.runPython(`'to_output' in globals()`);

                if (!hasFunction) {
                    throw new Error('Function to_output not defined in your code.');
                }

                // Run the to_output function on the input grid
                const outputGrid = pyodide.runPython(`
                    # Apply the to_output function to the grid
                    result_grid = to_output(create_grid_${taskNumber}())

                    # Render to get the 2D array
                    result_grid.render()
                `).toJs();

                // Display the output grid
                const safeIndex = taskNumber.toString().replace(/[^a-zA-Z0-9-]/g, '-');
                createAxisLabels(outputGrid, `predicted-output-x-${safeIndex}`, `predicted-output-y-${safeIndex}`);
                renderGridWithPopAnimation(outputGrid, `predicted-output-grid-${safeIndex}`);

                // Check if this is a training or test task
                const isTraining = transformButton.dataset.isTraining === 'true';
                const isTest = transformButton.dataset.isTest === 'true';
                
                if (isTraining) {
                    // TRAINING TASK - Show actual output and match percentage
                    // Get the actual output grid
                    const taskId = document.getElementById('task-select').value;
                    const task = taskList.find(t => t.id === taskId);
                    if (task && currentTask && currentTask.train && currentTask.train.length >= taskNumber) {
                        const actualOutput = currentTask.train[taskNumber-1].output;

                        // Calculate similarity 
                        const matchPercent = calculateSimilarity(outputGrid, actualOutput);

                        // Update match percentage in the task header
                        const taskHeader = document.querySelector(`#task-section-${taskNumber} .task-header .task-stats`);
                        const existingTransformMatchSpan = taskHeader.querySelector('.task-transform-match');
                        
                        if (existingTransformMatchSpan) {
                            existingTransformMatchSpan.textContent = `Transform: ${matchPercent.toFixed(1)}%`;
                            // Color the match based on percentage
                            if (matchPercent > 95) {
                                existingTransformMatchSpan.style.color = 'var(--button-color)'; // Green
                            } else if (matchPercent > 50) {
                                existingTransformMatchSpan.style.color = '#ffaa00'; // Orange
                            } else {
                                existingTransformMatchSpan.style.color = '#ff5959'; // Red
                            }
                        } else {
                            // Create new match span if it doesn't exist
                            const transformMatchSpan = document.createElement('span');
                            transformMatchSpan.className = 'task-transform-match';
                            transformMatchSpan.textContent = `Transform: ${matchPercent.toFixed(1)}%`;
                            
                            // Color the match based on percentage
                            if (matchPercent > 95) {
                                transformMatchSpan.style.color = 'var(--button-color)'; // Green
                            } else if (matchPercent > 50) {
                                transformMatchSpan.style.color = '#ffaa00'; // Orange
                            } else {
                                transformMatchSpan.style.color = '#ff5959'; // Red
                            }
                            
                            taskHeader.appendChild(transformMatchSpan);
                        }
                        
                        // Reset transform button text
                        transformButton.textContent = 'Run Transform';
                        
                        // Update solution stats for outputs
                        if (matchPercent > 95) {
                            // Mark this output as matched if it wasn't already
                            const outputIdx = taskNumber - 1;
                            if (outputIdx >= 0 && outputIdx < solutionStats.totalOutputs) {
                                if (!window[`outputMatched${taskNumber}`]) {
                                    window[`outputMatched${taskNumber}`] = true;
                                    solutionStats.matchedOutputs++;
                                    updateSolutionStats();
                                }
                            }
                        }

                        // Update the debug output to indicate success or failure
                        if (matchPercent === 100) {
                            document.getElementById('debug-output').textContent = 
                                `Perfect match for Task ${taskNumber}! Your transformation is correct.`;
                        } else if (matchPercent > 90) {
                            document.getElementById('debug-output').textContent = 
                                `Almost perfect for Task ${taskNumber}! (${matchPercent.toFixed(1)}% match)`;
                        } else if (matchPercent > 50) {
                            document.getElementById('debug-output').textContent = 
                                `Partial match for Task ${taskNumber}. (${matchPercent.toFixed(1)}% match)`;
                        } else {
                            document.getElementById('debug-output').textContent = 
                                `Low match for Task ${taskNumber}. Try a different approach. (${matchPercent.toFixed(1)}% match)`;
                        }
                    }
                } else if (isTest && actualOutput) {
                    // TEST TASK - Don't show actual output, just similarity percentage
                    // Calculate similarity but don't display the actual grid
                    const matchPercent = calculateSimilarity(outputGrid, actualOutput);
                    
                    // Update the feedback area with the match percentage
                    const feedbackArea = document.getElementById(`similarity-feedback-${safeIndex}`);
                    if (feedbackArea) {
                        // Create feedback message with similarity percentage
                        let feedbackHTML = `<div style="font-size:16px;margin-bottom:10px;">Similarity: <span style="font-weight:bold;`;
                        
                        // Color based on match percentage
                        if (matchPercent > 95) {
                            feedbackHTML += `color:var(--button-color)">High (${matchPercent.toFixed(1)}%)</span></div>`;
                        } else if (matchPercent > 60) {
                            feedbackHTML += `color:#ffaa00">Medium (${matchPercent.toFixed(1)}%)</span></div>`;
                        } else {
                            feedbackHTML += `color:#ff5959">Low (${matchPercent.toFixed(1)}%)</span></div>`;
                        }
                        
                        // Add tips based on similarity
                        if (matchPercent < 50) {
                            feedbackHTML += `<div style="font-size:13px;margin-top:10px;">Try a different approach.</div>`;
                        }
                        
                        feedbackArea.innerHTML = feedbackHTML;
                    }
                    
                    // Update match percentage in the task header
                    const taskHeader = document.querySelector(`#task-section-${taskNumber} .task-header .task-stats`);
                    const existingTransformMatchSpan = taskHeader.querySelector('.task-transform-match');
                    
                    if (existingTransformMatchSpan) {
                        existingTransformMatchSpan.textContent = `Transform: ${matchPercent.toFixed(1)}%`;
                        // Color the match based on percentage
                        if (matchPercent > 95) {
                            existingTransformMatchSpan.style.color = 'var(--button-color)'; // Green
                        } else if (matchPercent > 50) {
                            existingTransformMatchSpan.style.color = '#ffaa00'; // Orange
                        } else {
                            existingTransformMatchSpan.style.color = '#ff5959'; // Red
                        }
                    } else {
                        // Create new match span if it doesn't exist
                        const transformMatchSpan = document.createElement('span');
                        transformMatchSpan.className = 'task-transform-match';
                        transformMatchSpan.textContent = `Transform: ${matchPercent.toFixed(1)}%`;
                        
                        // Color the match based on percentage
                        if (matchPercent > 95) {
                            transformMatchSpan.style.color = 'var(--button-color)'; // Green
                        } else if (matchPercent > 50) {
                            transformMatchSpan.style.color = '#ffaa00'; // Orange
                        } else {
                            transformMatchSpan.style.color = '#ff5959'; // Red
                        }
                        
                        taskHeader.appendChild(transformMatchSpan);
                    }
                    
                    // Update solution stats for outputs
                    if (matchPercent > 95) {
                        // Mark this output as matched if it wasn't already
                        const outputIdx = taskNumber - 1;
                        if (outputIdx >= 0 && outputIdx < solutionStats.totalOutputs) {
                            if (!window[`outputMatched${taskNumber}`]) {
                                window[`outputMatched${taskNumber}`] = true;
                                solutionStats.matchedOutputs++;
                                updateSolutionStats();
                            }
                        }
                    }

                } else {
                    // Flash the button to indicate success
                    transformButton.style.backgroundColor = 'var(--button-active)';
                    setTimeout(() => {
                        transformButton.style.backgroundColor = '';
                    }, 500);
                }

            } catch (error) {
                console.error(`Error running transform for task ${taskNumber}:`, error);
                document.getElementById('debug-output').textContent = 
                    `Error: ${error.message}. Make sure you've defined to_output(grid) function in your code.`;
            }
        });
    }
}

// Initialize Pyodide
async function initializePyodide() {
    const debugOutput = document.getElementById('debug-output');
    const loadingOverlay = document.getElementById('loading-overlay');

    try {
        debugOutput.textContent = "Loading Python environment...";
        loadingOverlay.classList.add('active');

        pyodide = await loadPyodide();
        await pyodide.loadPackage(['numpy', 'micropip']);

        // Install pydantic using runPythonAsync which handles top-level await
        await pyodide.runPythonAsync(`
            import micropip
            await micropip.install('pydantic')
        `);

        // Import additional modules needed for module handling
        await pyodide.runPython(`
            import importlib.util
            import importlib.machinery
        `);

        // Initialize the code length measurement
        await initializeCodeMeasurement();

        loadingOverlay.classList.remove('active');
        debugOutput.textContent = "Python environment ready!";

        return true;
    } catch (error) {
        console.error('Error initializing Pyodide:', error);
        debugOutput.textContent = `Error initializing Python: ${error.message}`;
        loadingOverlay.classList.remove('active');
        return false;
    }
}

// Load the library and solution code into Pyodide
function loadPythonModules(libraryCode, solutionCode) {
    // Create library.py module
    pyodide.runPython(`
        # Create library.py module
        import sys
        from pathlib import Path

        # Create a virtual file for the library
        library_code = ${JSON.stringify(libraryCode)}

        # Create the library module
        spec = importlib.util.spec_from_loader('library', 
                                              importlib.machinery.SourceFileLoader('library', 'library.py'))
        library = importlib.util.module_from_spec(spec)
        sys.modules['library'] = library

        # Execute the library code in the module's namespace
        exec(library_code, library.__dict__)
    `);

    // Execute the solution code to make all functions available
    pyodide.runPython(solutionCode);
}

// Initialize the Python code for measuring code length
async function initializeCodeMeasurement() {
    // Load the ast module for code analysis
    await pyodide.runPython(`
        import ast

        class SimpleTokenCounter(ast.NodeVisitor):
            def __init__(self):
                self.count = 0

            def generic_visit(self, node):
                # Increment count for each relevant node type
                if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.Name, ast.arg,
                                        ast.Import, ast.ImportFrom, ast.Constant, ast.Attribute,
                                        ast.BinOp, ast.Compare, ast.If, ast.For, ast.While, 
                                        ast.Return, ast.Call)):
                    self.count += 1
                super().generic_visit(node)

        def measure_code_length(code):
            try:
                tree = ast.parse(code)
                counter = SimpleTokenCounter()
                counter.visit(tree)
                return counter.count
            except SyntaxError:
                # Return a large number if there's a syntax error
                return 9999
    `);
}

// Function to measure the code length
function measureCodeLength(code) {
    try {
        // Use the Python function to measure code length
        const length = pyodide.runPython(`measure_code_length(${JSON.stringify(code)})`);
        return length;
    } catch (error) {
        console.error('Error measuring code length:', error);
        return 0;
    }
}

// Helper function to create a grid wrapper
function createGridWrapper(title, gridId, xLabelsId, yLabelsId) {
    return `
        <div class="grid-comparison-title">${title}</div>
        <div class="grid-wrapper">
            <div class="grid-inner">
                <div class="origin-marker"></div>
                <div class="origin-label">0</div>
                <div class="axis-name x-name">X</div>
                <div class="axis-name y-name">Y</div>
                <div class="x-arrow-right"></div>
                <div class="y-arrow-down"></div>
                <div class="axis-labels x-labels" id="${xLabelsId}"></div>
                <div class="axis-labels y-labels" id="${yLabelsId}"></div>
                <div class="grid" id="${gridId}"></div>
            </div>
        </div>
    `;
}

// Helper function to create a button container
function createButtonContainer(button) {
    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.justifyContent = 'center';
    container.style.width = '100%';
    container.style.margin = '10px 0';
    container.appendChild(button);
    return container;
}

// Create the input comparison section
function createInputComparison(taskNumber, safeIndex) {
    const inputComparison = document.createElement('div');
    inputComparison.className = 'grid-comparison';

    // The "run prediction" button
    const runPredictionButton = document.createElement('button');
    runPredictionButton.type = 'button';
    runPredictionButton.className = 'run-transform-button';
    runPredictionButton.id = `run-prediction-${taskNumber}`;
    runPredictionButton.textContent = 'Run Prediction';
    runPredictionButton.dataset.taskNumber = taskNumber;

    // Actual input grid
    const actualInputColumn = document.createElement('div');
    actualInputColumn.className = 'grid-comparison-column';
    actualInputColumn.innerHTML = createGridWrapper(
        'Actual Input',
        `actual-input-grid-${safeIndex}`,
        `actual-input-x-${safeIndex}`,
        `actual-input-y-${safeIndex}`
    );

    // Predicted input grid
    const predictedInputColumn = document.createElement('div');
    predictedInputColumn.className = 'grid-comparison-column';
    predictedInputColumn.innerHTML = createGridWrapper(
        'Your Prediction',
        `predicted-input-grid-${safeIndex}`,
        `predicted-input-x-${safeIndex}`,
        `predicted-input-y-${safeIndex}`
    );

    // Assemble input comparison section
    inputComparison.appendChild(actualInputColumn);
    inputComparison.appendChild(predictedInputColumn);

    return {
        comparison: inputComparison,
        button: runPredictionButton
    };
}

// Create the output comparison section for training tasks
function createTrainingOutputComparison(taskNumber, safeIndex, isTraining) {
    const outputComparison = document.createElement('div');
    outputComparison.className = 'grid-comparison';

    // The "run transform" button
    const runTransformButton = document.createElement('button');
    runTransformButton.type = 'button';
    runTransformButton.className = 'run-transform-button';
    runTransformButton.id = `run-transform-${taskNumber}`;
    runTransformButton.textContent = 'Run Transform';
    runTransformButton.dataset.taskNumber = taskNumber;
    runTransformButton.dataset.isTraining = isTraining.toString();
    runTransformButton.disabled = true; // Initially disabled

    // Actual output grid
    const actualOutputColumn = document.createElement('div');
    actualOutputColumn.className = 'grid-comparison-column';
    actualOutputColumn.innerHTML = createGridWrapper(
        'Actual Output',
        `actual-output-grid-${safeIndex}`,
        `actual-output-x-${safeIndex}`,
        `actual-output-y-${safeIndex}`
    );

    // Predicted output grid
    const predictedOutputColumn = document.createElement('div');
    predictedOutputColumn.className = 'grid-comparison-column';
    predictedOutputColumn.innerHTML = createGridWrapper(
        'Your Transform',
        `predicted-output-grid-${safeIndex}`,
        `predicted-output-x-${safeIndex}`,
        `predicted-output-y-${safeIndex}`
    );

    // Assemble output comparison
    outputComparison.appendChild(actualOutputColumn);
    outputComparison.appendChild(predictedOutputColumn);

    return {
        comparison: outputComparison,
        button: runTransformButton
    };
}

// Create the output comparison section for test tasks
function createTestOutputComparison(taskNumber, safeIndex, actualOutput) {
    const outputComparison = document.createElement('div');
    outputComparison.className = 'grid-comparison';

    // The "run transform" button
    const runTransformButton = document.createElement('button');
    runTransformButton.type = 'button';
    runTransformButton.className = 'run-transform-button';
    runTransformButton.id = `run-transform-${taskNumber}`;
    runTransformButton.textContent = 'Run Transform';
    runTransformButton.dataset.taskNumber = taskNumber;
    runTransformButton.dataset.isTraining = 'false';
    runTransformButton.dataset.isTest = 'true';
    runTransformButton.disabled = true; // Initially disabled

    // Store the actual output for comparison (not shown to user)
    if (actualOutput) {
        runTransformButton.dataset.hasActualOutput = 'true';
        // Store output dimensions to create a placeholder of the same size
        runTransformButton.dataset.outputRows = actualOutput.length;
        runTransformButton.dataset.outputCols = actualOutput[0].length;
    } else {
        runTransformButton.dataset.hasActualOutput = 'false';
    }

    // Info message
    const infoMessage = document.createElement('div');
    infoMessage.className = 'task-warning';
    infoMessage.textContent = 'This is a test task. The actual output is hidden, but your solution will be checked for similarity.';

    // Left column with similarity feedback (not showing actual output)
    const feedbackColumn = document.createElement('div');
    feedbackColumn.className = 'grid-comparison-column';
    feedbackColumn.innerHTML = `
        <div class="grid-comparison-title">Test Task</div>
        ${infoMessage.outerHTML}
        <div id="similarity-feedback-${safeIndex}" style="margin-top:15px;text-align:center;"></div>
    `;

    // Predicted output grid
    const predictedOutputColumn = document.createElement('div');
    predictedOutputColumn.className = 'grid-comparison-column';
    predictedOutputColumn.innerHTML = createGridWrapper(
        'Your Transform',
        `predicted-output-grid-${safeIndex}`,
        `predicted-output-x-${safeIndex}`,
        `predicted-output-y-${safeIndex}`
    );

    // Assemble output comparison
    outputComparison.appendChild(feedbackColumn);
    outputComparison.appendChild(predictedOutputColumn);

    return {
        comparison: outputComparison,
        button: runTransformButton
    };
}

// Create a task section for input-output pairs
function createTaskSection(taskNumber, inputGrid, outputGrid, isTraining, taskType = "Training") {
    // Create the containing section
    const section = document.createElement('div');
    section.className = 'task-section';
    section.id = `task-section-${taskNumber}`;

    // Calculate grid stats for display
    const inputSize = `${inputGrid.length}Ã—${inputGrid[0].length}`;
    const inputColors = countUniqueColors(inputGrid);

    // Create the header
    const header = document.createElement('div');
    header.className = 'task-header';
    header.innerHTML = `
        <div class="task-title">${taskType} Task ${taskNumber}</div>
        <div class="task-stats">
            <span class="task-size">Size: ${inputSize}</span>
            <span class="task-colors">Colors: ${inputColors}</span>
        </div>
    `;

    // Create content container (open by default for first task)
    const content = document.createElement('div');
    content.className = 'task-content';
    if (taskNumber === 1) {
        content.style.maxHeight = '1200px'; // Initial height for open state
    } else {
        content.classList.add('collapsed');
    }

    // Generate unique IDs for all grids
    const safeIndex = taskNumber.toString().replace(/[^a-zA-Z0-9-]/g, '-');

    // Create the input comparison section
    const inputSection = createInputComparison(taskNumber, safeIndex);
    content.appendChild(inputSection.comparison);
    content.appendChild(createButtonContainer(inputSection.button));

    // Create output comparison section based on task type
    if (taskType === "Training" && isTraining && outputGrid) {
        // Show actual output for training tasks
        const outputSection = createTrainingOutputComparison(taskNumber, safeIndex, isTraining);
        content.appendChild(outputSection.comparison);
        content.appendChild(createButtonContainer(outputSection.button));
    } else if (taskType === "Test") {
        // For test tasks, show the comparison section but don't show the actual output
        const outputSection = createTestOutputComparison(taskNumber, safeIndex, outputGrid);
        content.appendChild(outputSection.comparison);
        content.appendChild(createButtonContainer(outputSection.button));
    }

    // Add toggle functionality
    header.addEventListener('click', (e) => {
        // Don't toggle if a button was clicked
        if (e.target.tagName === 'BUTTON') return;

        const isCollapsed = content.classList.contains('collapsed');
        if (isCollapsed) {
            content.classList.remove('collapsed');
            content.style.maxHeight = '1200px'; // Open state
        } else {
            content.classList.add('collapsed');
            content.style.maxHeight = '0'; // Collapsed state
        }
    });

    // Assemble the task section
    section.appendChild(header);
    section.appendChild(content);

    // Return the section now
    // We'll handle rendering after it's added to the DOM
    return {
        section,
        renderGrids: () => {
            // Wait for next tick to ensure DOM elements are accessible
            setTimeout(() => {
                try {
                    // Render actual input grid
                    createAxisLabels(inputGrid, `actual-input-x-${safeIndex}`, `actual-input-y-${safeIndex}`);
                    renderGrid(inputGrid, `actual-input-grid-${safeIndex}`);

                    // Render actual output grid if available for training tasks
                    if (taskType === "Training" && isTraining && outputGrid) {
                        createAxisLabels(outputGrid, `actual-output-x-${safeIndex}`, `actual-output-y-${safeIndex}`);
                        renderGrid(outputGrid, `actual-output-grid-${safeIndex}`);
                    }
                } catch (error) {
                    console.error('Error rendering grids:', error);
                }
            }, 0);
        }
    };
}

// Count unique colors in a grid
function countUniqueColors(gridData) {
    const colorSet = new Set();
    gridData.forEach(row => {
        row.forEach(cell => {
            colorSet.add(cell);
        });
    });
    return colorSet.size;
}

// Update solution stats display
function updateSolutionStatsDisplay() {
    document.getElementById('inputs-matched').textContent = 
        `${solutionStats.matchedInputs}/${solutionStats.totalInputs} (${Math.round((solutionStats.matchedInputs / solutionStats.totalInputs) * 100) || 0}%)`;
    
    document.getElementById('outputs-matched').textContent = 
        `${solutionStats.matchedOutputs}/${solutionStats.totalOutputs} (${Math.round((solutionStats.matchedOutputs / solutionStats.totalOutputs) * 100) || 0}%)`;
    
    document.getElementById('task-status').textContent = solutionStats.taskStatus;
    
    // Style the task status based on completion
    const taskStatusElement = document.getElementById('task-status');
    if (solutionStats.taskStatus === 'Solved') {
        taskStatusElement.style.color = 'var(--button-color)'; // Green
        taskStatusElement.style.fontWeight = 'bold';
    } else if (solutionStats.taskStatus === 'In progress') {
        taskStatusElement.style.color = '#ffaa00'; // Orange
        taskStatusElement.style.fontWeight = 'bold';
    } else {
        taskStatusElement.style.color = ''; // Default
        taskStatusElement.style.fontWeight = 'normal';
    }
}

// Update solution stats from input/output matches
function updateSolutionStats() {
    // Check if we've matched all inputs and outputs
    if (solutionStats.matchedInputs === solutionStats.totalInputs && 
        solutionStats.matchedOutputs === solutionStats.totalOutputs && 
        solutionStats.totalInputs > 0) {
        solutionStats.taskStatus = 'Solved';
    } else if (solutionStats.matchedInputs > 0 || solutionStats.matchedOutputs > 0) {
        solutionStats.taskStatus = 'In progress';
    } else {
        solutionStats.taskStatus = 'Not started';
    }
    
    // Update the display
    updateSolutionStatsDisplay();
}

// Run the Python code
async function runPythonCode(isInitialLoad = false) {
    if (!pyodide) {
        await initializePyodide();
        if (!pyodide) return; // Failed to initialize
    }

    const libraryCode = libraryEditor.getValue();
    const solutionCode = solutionEditor.getValue();
    const button = document.getElementById('run-button');
    const loadingOverlay = document.getElementById('loading-overlay');
    const statusIndicator = document.getElementById('status-indicator');
    const debugOutput = document.getElementById('debug-output');

    // Prevent multiple clicks (skip if initial load)
    if (!isInitialLoad && button.classList.contains('running')) {
        return;
    }

    // Show running state (skip if initial load)
    if (!isInitialLoad) {
        button.classList.add('running');
        loadingOverlay.classList.add('active');
        statusIndicator.classList.add('active');
        debugOutput.textContent = "Running Python code...";
    }

    try {
        // Load the Python modules
        loadPythonModules(libraryCode, solutionCode);

        // Check if solution code has basic syntax errors
        try {
            // Syntax check by analyzing AST (without executing code)
            pyodide.runPython(`
                import ast

                # Check syntax without executing
                try:
                    ast.parse(${JSON.stringify(solutionCode)})
                except SyntaxError as e:
                    raise SyntaxError(f"Syntax error in your code: {str(e)}")
            `);

            if (!isInitialLoad) {
                debugOutput.textContent = "Code looks good! Use the Run Prediction and Run Transform buttons for each task.";
            }
        } catch (error) {
            console.error('Syntax error in code:', error);
            if (!isInitialLoad) {
                throw error;
            }
        }

        // Measure and update code length - only count the solution code, not the library
        const solutionLength = measureCodeLength(solutionCode);
        document.getElementById('code-length').textContent = `${solutionLength} tokens`;

        debugOutput.textContent = "Code executed successfully! Use the Run Prediction and Run Transform buttons for each task.";
    } catch (error) {
        console.error('Error running Python code:', error);
        if (!isInitialLoad) {
            debugOutput.textContent = `Error: ${error.message}`;
        }
    } finally {
        // Hide running state (only if not initial load)
        if (!isInitialLoad) {
            setTimeout(() => {
                button.classList.remove('running');
                loadingOverlay.classList.remove('active');
                statusIndicator.classList.remove('active');
            }, 800);
        }
    }
}

// Panel resizer functionality
function initializeResizer() {
    const panelResizer = document.getElementById('panel-resizer');
    const editorPanel = document.querySelector('.editor-panel');
    const gridPanel = document.querySelector('.grid-panel');
    const container = document.querySelector('.container');

    let isResizing = false;
    let lastDownX = 0;

    panelResizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        lastDownX = e.clientX;
        panelResizer.classList.add('active');

        // Prevent text selection during resize
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'col-resize';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        // Check if we're in mobile mode
        const isMobileMode = window.matchMedia('(max-width: 768px)').matches;

        if (isMobileMode) {
            // Handle vertical resizing for mobile
            const containerRect = container.getBoundingClientRect();
            const offsetY = e.clientY - containerRect.top;

            // Calculate constraints
            const minHeight = 200;
            const maxHeight = containerRect.height - 200;

            // Apply constraints
            const newHeight = Math.min(Math.max(offsetY, minHeight), maxHeight);

            // Update editor panel height
            editorPanel.style.height = `${newHeight}px`;
            editorPanel.style.flex = 'none';
        } else {
            // Handle horizontal resizing for desktop
            const containerRect = container.getBoundingClientRect();
            const offsetX = e.clientX - containerRect.left;

            // Calculate min/max values
            const minWidth = 200;
            const maxWidth = containerRect.width - 200;

            // Apply constraints
            const newWidth = Math.min(Math.max(offsetX, minWidth), maxWidth);

            // Update editor panel width
            editorPanel.style.flex = '0 0 ' + newWidth + 'px';
        }

        // Force Ace editors to update their size
        if (solutionEditor) {
            solutionEditor.resize();
        }
        if (libraryEditor) {
            libraryEditor.resize();
        }
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            panelResizer.classList.remove('active');

            // Reset cursor and selection
            document.body.style.userSelect = '';
            document.body.style.cursor = '';

            // Make sure editors resize properly
            if (solutionEditor) {
                solutionEditor.resize();
            }
            if (libraryEditor) {
                libraryEditor.resize();
            }
        }
    });

    // Resize editor when window changes
    window.addEventListener('resize', () => {
        // Resize editors to fit the new layout
        if (solutionEditor) {
            solutionEditor.resize();
        }
        if (libraryEditor) {
            libraryEditor.resize();
        }
    });
}

// Task selector change handler
function initializeTaskSelector() {
    const taskSelect = document.getElementById('task-select');
    taskSelect.addEventListener('change', (e) => {
        loadTask(e.target.value);
    });
}

// Initialize everything
async function initialize() {
    // Initialize components
    initializeEditor();
    initializeResizer();
    initializeTaskSelector();

    // Load task list 
    await loadTaskList();

    // Initialize Pyodide in the background
    await initializePyodide();

    // Add click handler for the run button
    const runButton = document.getElementById('run-button');
    runButton.addEventListener('click', runPythonCode);

    // Run the code once to check syntax and load functions
    try {
        await runPythonCode(true); // Pass true to indicate this is the initial load
    } catch (e) {
        console.log("Initial code execution failed, but that's okay - user can fix and run again.");
    }
}

// Run initialization when DOM is loaded
document.addEventListener('DOMContentLoaded', initialize);
</script>
</body>
</html>